## Выбор парадигмы программирования

В данном проекте была выбрана **объектно-ориентированная парадигма программирования**. Обоснование данного выбора заключается в том, что объектно-ориентированное программирование (ООП) предоставляет более удобные и гибкие инструменты для организации кода, повышения его читаемости, поддержания и расширения.

## Обоснование выбора парадигмы

1. **Инкапсуляция**: В ООП данные и методы, которые с ними работают, объединяются в объекты. Это позволяет скрыть детали реализации от внешнего мира. В нашем проекте классы `MultiplicationTableGenerator`, `ConsoleMultiplicationTablePrinter` и `InvalidInputException` являются объектами, которые инкапсулируют свои данные и методы, что способствует сокрытию деталей реализации.

2. **Наследование**: ООП поддерживает наследование, что позволяет создавать новые классы на основе существующих. Наследование способствует повторному использованию кода. В нашем проекте мы могли бы создать подклассы, расширяющие функциональность базовых классов.

3. **Полиморфизм**: ООП позволяет использовать объекты разных классов с одним и тем же интерфейсом. Это упрощает обмен объектами между частями программы. Например, интерфейс `IMultiplicationTablePrinter` позволяет работать с различными классами, реализующими печать таблицы умножения.

4. **Читаемость кода**: ООП способствует лучшей организации кода. Классы и объекты позволяют структурировать программу на логические компоненты, что упрощает понимание и сопровождение кода. Комментарии Javadoc в нашем проекте также делают код более понятным.

5. **Модульность и уровень абстракции**: ООП позволяет создавать модули с разной степенью абстракции. Например, класс `MultiplicationTableGenerator` отвечает за бизнес-логику, а `IMultiplicationTablePrinter` абстрагирует способ вывода. Это упрощает разделение задач и снижает связанность между компонентами.

Общий вывод: ООП облегчает создание сложных программ, улучшает их структуру, уменьшает сложность и способствует повторному использованию кода. В нашем проекте он позволил лучше организовать бизнес-логику, инкапсулировать данные и методы, а также сделать код более читаемым и расширяемым по сравнению с процедурным подходом.