## 1. Секундомер

Для решения задачи создания секундомера я выбрал парадигму объектно-ориентированного программирования (ООП). Вот несколько причин этого выбора:

1. Абстракция: ООП позволяет абстрагироваться от деталей реализации и сосредотачиваться на моделировании объектов и их взаимодействии. В данной задаче секундомер может быть представлен как объект с определенными свойствами (время начала, время в паузе и т. д.) и методами (запуск, пауза, остановка). Это позволяет легче понимать и поддерживать код.

2. Инкапсуляция: ООП поддерживает принцип инкапсуляции, который позволяет скрывать детали реализации и предоставлять только необходимый интерфейс. В данной задаче класс `Stopwatch` инкапсулирует состояние и поведение секундомера, делая код более понятным и безопасным.

3. Повторное использование кода: ООП способствует повторному использованию кода. Если в будущем потребуется создать секундомер в другой части приложения или добавить новые функции, то класс `Stopwatch` можно легко повторно использовать без изменения других частей приложения.

4. Разделение ответственностей: ООП позволяет разделить функциональность на небольшие, независимые компоненты (классы). Это облегчает поддержку и разработку кода, а также упрощает поиск и устранение ошибок.

5. Читаемость кода: ООП способствует написанию читаемого и структурированного кода. Методы и поля класса `Stopwatch` имеют ясные и понятные названия, что упрощает понимание, как использовать секундомер.

## 2. MSE

Решая задачу вычисления среднеквадратичной ошибки (MSE) для оценки точности модели прогнозирования продаж, я предпочел использовать функциональную парадигму программирования. Вот мои основания для выбора этой парадигмы:

1. Декларативность: Функциональное программирование предоставляет декларативный способ описания вычислений. Это позволяет сосредоточиться на том, **что** мы хотим получить (MSE), а не на том, **как** его получить. В моем коде, я описываю вычисления, которые должны быть выполнены, а не шаги, которые нужно выполнить.

2. Иммутабельность: Функциональное программирование обычно подразумевает неизменяемость данных. Это полезно, потому что данные в моей задаче остаются неизменными, и мы избегаем неожиданных побочных эффектов.

3. Краткость и читаемость: Функциональный стиль кода может быть более кратким и легко читаемым. В моей реализации, я использую потоки данных (Stream API) и лямбда-выражения для краткости и выразительности, что делает код более понятным и менее подверженным ошибкам.

4. Использование стандартных операций: Функциональная парадигма позволяет использовать стандартные операции, такие как `map`, `reduce`, и `average`, что делает код более удобным и уменьшает вероятность ошибок.

5. Реиспользование кода: Функциональный подход способствует созданию кода, который может быть легко переиспользован в других частях программы или проекта. Моя функция `calculateMSE` может быть использована в различных сценариях без изменения.

## 3. Merge sort

