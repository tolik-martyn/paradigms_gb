## 1. Секундомер

Для решения задачи создания секундомера я выбрал парадигму объектно-ориентированного программирования (ООП). Вот несколько причин этого выбора:

1. Абстракция: ООП позволяет абстрагироваться от деталей реализации и сосредотачиваться на моделировании объектов и их взаимодействии. В данной задаче секундомер может быть представлен как объект с определенными свойствами (время начала, время в паузе и т. д.) и методами (запуск, пауза, остановка). Это позволяет легче понимать и поддерживать код.

2. Инкапсуляция: ООП поддерживает принцип инкапсуляции, который позволяет скрывать детали реализации и предоставлять только необходимый интерфейс. В данной задаче класс `Stopwatch` инкапсулирует состояние и поведение секундомера, делая код более понятным и безопасным.

3. Повторное использование кода: ООП способствует повторному использованию кода. Если в будущем потребуется создать секундомер в другой части приложения или добавить новые функции, то класс `Stopwatch` можно легко повторно использовать без изменения других частей приложения.

4. Разделение ответственностей: ООП позволяет разделить функциональность на небольшие, независимые компоненты (классы). Это облегчает поддержку и разработку кода, а также упрощает поиск и устранение ошибок.

5. Читаемость кода: ООП способствует написанию читаемого и структурированного кода. Методы и поля класса `Stopwatch` имеют ясные и понятные названия, что упрощает понимание, как использовать секундомер.

## 2. MSE

Решая задачу вычисления среднеквадратичной ошибки (MSE) для оценки точности модели прогнозирования продаж, я предпочел использовать функциональную парадигму программирования. Вот мои основания для выбора этой парадигмы:

1. Декларативность: Функциональное программирование предоставляет декларативный способ описания вычислений. Это позволяет сосредоточиться на том, **что** мы хотим получить (MSE), а не на том, **как** его получить. В моем коде, я описываю вычисления, которые должны быть выполнены, а не шаги, которые нужно выполнить.

2. Иммутабельность: Функциональное программирование обычно подразумевает неизменяемость данных. Это полезно, потому что данные в моей задаче остаются неизменными, и мы избегаем неожиданных побочных эффектов.

3. Краткость и читаемость: Функциональный стиль кода может быть более кратким и легко читаемым. В моей реализации, я использую потоки данных (Stream API) и лямбда-выражения для краткости и выразительности, что делает код более понятным и менее подверженным ошибкам.

4. Использование стандартных операций: Функциональная парадигма позволяет использовать стандартные операции, такие как `map`, `reduce`, и `average`, что делает код более удобным и уменьшает вероятность ошибок.

5. Реиспользование кода: Функциональный подход способствует созданию кода, который может быть легко переиспользован в других частях программы или проекта. Моя функция `calculateMSE` может быть использована в различных сценариях без изменения.

## 3. Merge sort

Для решения задачи сортировки массива слиянием, я выбрал функциональную парадигму программирования, и вот почему:

1. **Естественная рекурсия**: Сама сортировка слиянием натуральным образом подразумевает рекурсивный процесс. Мы разделяем массив на меньшие части, сортируем их, а затем объединяем. Функциональная парадигма предоставляет естественные средства для работы с рекурсией, делая код более наглядным и легко понимаемым.

2. **Неизменяемость данных**: Функциональное программирование способствует работе с неизменяемыми данными. Это важно в контексте сортировки, так как оригинальный массив остается без изменений, и мы создаем новые массивы на каждом шаге. Это помогает избегать побочных эффектов и упрощает отладку.

3. **Чистые функции**: Функциональные программы обычно работают с чистыми функциями, которые не имеют побочных эффектов и всегда возвращают одинаковый результат для одинаковых входных данных. В данной задаче, наши функции `mergeSort` и `merge` могут быть рассмотрены как чистые функции, что упрощает их тестирование и понимание.

4. **Удобство тестирования**: Функциональные программы легче тестируются, потому что функции обычно зависят только от входных данных и не изменяют состояние программы. Это делает код сортировки слиянием более надежным и предсказуемым.

5. **Повторное использование кода**: Функциональный стиль программирования способствует созданию многоразовых функций, которые могут быть легко переиспользованы в других частях программы. В случае сортировки слиянием, это означает, что наша реализация может быть использована в различных контекстах без изменения.

## 4. Binary search

Я выбрал процедурную парадигму программирования для реализации бинарного поиска, поскольку данная задача имеет четкий набор последовательных шагов и требует итеративного подхода к решению. Вот обоснования моего выбора:

1. **Итеративный характер задачи**: Бинарный поиск - это алгоритм, который выполняет последовательные итерации, сужая диапазон поиска до нахождения искомого элемента или его отсутствия. Процедурный стиль программирования подходит для реализации таких последовательных шагов.

2. **Простота понимания**: Процедурный стиль позволяет разбить задачу на более мелкие процедуры или шаги, что делает код более понятным и удобным для чтения и понимания. В случае бинарного поиска, это означает разделение алгоритма на шаги, такие как вычисление средней точки и сравнение с целевым значением.

3. **Простота реализации и отладки**: Процедурный код обычно имеет более низкий порог входа, что означает, что он может быть реализован и отлажен относительно быстро. В контексте бинарного поиска, где нам нужно просто следовать последовательности шагов, это может упростить разработку и отладку.

4. **Понятность для других разработчиков**: Процедурный стиль программирования обеспечивает четкую последовательность шагов, которую легко понять и интерпретировать другим разработчикам, что облегчает совместную работу над проектом.

5. **Эффективность и производительность**: Процедурный стиль обеспечивает низкий уровень абстракции, что может быть полезно для оптимизации производительности в некоторых случаях. В случае бинарного поиска, где каждая итерация имеет строго определенные действия, это может быть важным аспектом.